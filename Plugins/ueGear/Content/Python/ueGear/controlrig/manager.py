from typing import Optional

import unreal

from ueGear import assets as ue_assets
from ueGear.controlrig import mgear
from ueGear.controlrig import components
from ueGear.controlrig.components import EPIC_control_01


class UEGearManager:
    _factory: unreal.ControlRigBlueprintFactory = None
    """Unreals Control Rig Blue Print Factory. This performs all the alterations to the Control Rig"""

    _cr_blueprints: list[unreal.ControlRigBlueprint] = []
    """List of all available blueprints"""

    _active_blueprint: unreal.ControlRigBlueprint = None
    """The Active Blueprint is the current blueprint that will be modified by the UE Gear Manager"""

    _ue_gear_standard_library = None

    mg_rig: mgear.mgRig = None
    """The mGear rig description, that is used to generate the ueGear 'Control Rig'"""

    uegear_components: list[components.base_component.UEComponent] = []
    """Keeps track of all the created components that relate the the mGear Rig being created. There
    are the components that were deserialised fomr the `.gnx` file"""

    _buildConstructionControlFunctions = True
    """If True, When building the Control Rig all controls will be generated by the construction node(Function). The 
    pro of this is each control will generate after compiling the Control Rig, the down side is you cannot alter the rig
    post mGear build.
    
    Build with this set to False if you wish to modify your rig post build.
    """

    # Thought: We could create a wrapper object that encompasses both mgear and ueGear rigs. keeping them more coupled, for easier data manipulation. but this will add to complexity.

    @property
    def active_control_rig(self):
        return self._active_blueprint

    @active_control_rig.setter
    def active_control_rig(self, value):
        self._active_blueprint = value

    def __init__(self) -> None:
        """
        Initialises the ueGear Manager, making sure that the plugin exists and the factory has been accessed.
        """
        self.reset()

        unreal.load_module('ControlRigDeveloper')
        self._factory = unreal.ControlRigBlueprintFactory
        self.get_open_controlrig_blueprints()

        # # Generates the 'Create', 'Forward' and 'Backwards' nodes
        # self.create_solves()

    def reset(self):
        """Clears all the stored blueprint data"""
        self._factory = None
        self._cr_blueprints = []
        self._active_blueprint = None
        self._ue_gear_standard_library = None
        self.mg_rig = None
        self.uegear_components = []
        self._buildConstructionControlFunctions = True

    def get_open_controlrig_blueprints(self):
        """Gets all open Control Rig Blueprints

        Defaults the active CR BP to the first element in the list
        """
        cr_blueprints = unreal.ControlRigBlueprint.get_currently_open_rig_blueprints()

        self._set_control_blueprint(cr_blueprints)

        return self._cr_blueprints

    def _set_control_blueprint(self, control_blueprints):
        """
        Assigns all the control blueprints and will assign the first element to the active CR BP

        :param list(unreal.ControlRigBlueprint) control_blueprints: list of control rig blueprints.
        """
        self._cr_blueprints = control_blueprints

        # No CR BP found to be open.
        if len(self._cr_blueprints) == 0:
            self.set_active_blueprint(None)
            self._cr_blueprints = []
            return None

        self.set_active_blueprint(self._cr_blueprints[0])

    def set_active_blueprint(self, bp: unreal.ControlRigBlueprint):
        """Sets the blueprint that will be getting modified by the ueGearManager

        The Control Rig Blueprint that will be modified by the  manager, is referred to as the "Active Blueprint"
        """
        self._active_blueprint = bp

    def get_compile_mode(self) -> bool:
        """Gets the Auto Compile status on the Blueprint of the active blueprint"""
        return self._active_blueprint.get_auto_vm_recompile()

    def set_compile_mode(self, active=True):
        """Sets the Auto Compile status on the Blueprint of the active blueprint"""
        self._active_blueprint.set_auto_vm_recompile(active)

    # todo: Add "manual" build for world control
    def build_world_control(self, force_build=False):
        """
        Generates the world contol. The control will come in at world origin
         - Control is also world aligned.

        :return:
        """
        controller = self.get_active_controller()

        create_ctrl = self.mg_rig.settings["worldCtl"]
        name = self.mg_rig.settings["world_ctl_name"]

        if force_build:
            create_ctrl = True
            name.get("world_ctl_name", "world_ctl")

        if not create_ctrl:
            return

        # Creates the Forward,Backwards and Construction event
        self.create_solves()

        # Create Automatic built world control
        if self._buildConstructionControlFunctions:
            # As the world control is not a specific component in mGear, we create a psudo
            # component for it.
            placeholder_component = mgear.mgComponent()
            placeholder_component.controls = [name]
            placeholder_component.joints = None
            placeholder_component.comp_type = "world_ctl"
            # populating the boundin box
            placeholder_component.controls_aabb = dict()
            placeholder_component.controls_aabb[name] = [[0, 0, 0], [120.0, 120.0, 120.0]]

            ueg_comp = EPIC_control_01.Component()
            ueg_comp.metadata = placeholder_component
            ueg_comp.name = name

            self.uegear_components.append(ueg_comp)

            ueg_comp.create_functions(controller)

            # Orients the control shape
            ueg_comp.populate_control_shape_orientation(controller)
            ueg_comp.populate_control_scale(controller)

            cr_func = ueg_comp.functions["construction_functions"][0]
            construction_node = f"{ueg_comp.name}_{cr_func}"
            controller.set_pin_default_value(f'{construction_node}.control_orientation.X',
                                             '0.0',
                                             False)

        else:
            placeholder_component = mgear.mgComponent()
            placeholder_component.controls = [name]
            placeholder_component.joints = None
            placeholder_component.comp_type = "world_ctl"
            # populating the boundin box
            placeholder_component.controls_aabb = dict()
            placeholder_component.controls_aabb[name] = [[0, 0, 0], [120.0, 120.0, 120.0]]

            placeholder_component.control_transforms = dict()
            placeholder_component.control_transforms["world_ctl"] = unreal.Transform()

            placeholder_component.controls_colour = dict()
            placeholder_component.controls_colour["world_ctl"] = [1,0,0]

            placeholder_component.controls_role = dict()
            placeholder_component.controls_role["world_ctl"] = "root"

            placeholder_component.control_relatives = dict()
            placeholder_component.control_relatives["root"] = "world_ctl"

            ueg_comp = EPIC_control_01.ManualComponent()
            ueg_comp.metadata = placeholder_component
            ueg_comp.name = name

            self.uegear_components.append(ueg_comp)

            ueg_comp.create_functions(controller)
            ueg_comp.generate_manual_controls(self._active_blueprint.get_hierarchy_controller())

            # Sets the world control's shape rotation to 0
            ueg_comp.control_by_role["root"].shape_transform_global(rotation=[0, 0, 0])

    def build_component(self, name, manual_component=False):
        """Create an individual component from the mgear scene desciptor file.

        name:
            name of the component that will be getting built.
        manual_component:
            If enabled the builder will try and utilise the manual components classes.
            These are the second class that exists in the component.py file. These
            classes have there controls generated using Python and not the
            Construction nodes.
        """

        print("------------------------------")
        print(f" BUILDING COMPONENT: {name}")
        print("------------------------------")

        if self._active_blueprint is None:
            unreal.log_error("ueGear Manager > Cannot create Control Rig Blueprint, please specify active blueprint.")

        guide_component = self.mg_rig.components.get(name, None)

        if guide_component is None:
            unreal.log_warning(f"Unable to find component, {name}")
            return None

        guide_type = guide_component.comp_type
        guide_name = guide_component.fullname

        # Finds the ueGear Component class that matches the guide data class type.
        ue_comp_classes = components.lookup_mgear_component(guide_type)

        # If component not found, report error and exit early
        if ue_comp_classes is None or not ue_comp_classes:
            unreal.log_warning(f"Component not found : {guide_type}")
            return

        print("Build Component")
        print(ue_comp_classes)
        print(guide_type)

        ueg_comp_class = ue_comp_classes[0]

        # Instantiates the component
        if manual_component:
            # If manual component is enabled then it will try and instanciate the
            # second class in the component file, which should be the manual component
            ueg_comp_class = ue_comp_classes[1]

        ueg_comp = ueg_comp_class()
        ueg_comp.metadata = guide_component  # Could be moved into the init of the ueGear component class
        ueg_comp.name = guide_component.fullname

        self.uegear_components.append(ueg_comp)

        print(f"         NAME : {ueg_comp.name}")
        print(f"   mGear Comp : {ueg_comp.mgear_component}")
        print(f"    Functions : {ueg_comp.functions}")
        print(f"   Guide Name : {guide_name}")
        print(f"     metadata :\n {ueg_comp.metadata}")
        print("--------------------")

        bp_controller = self.get_active_controller()

        # Create Function Nodes
        ueg_comp.create_functions(bp_controller)

        # Only evaluates manual building on manual controls
        # This is required to be placed here as we need to pass in the hierarchy controller.
        if ueg_comp.is_manual:
            ueg_comp.generate_manual_controls(self._active_blueprint.get_hierarchy_controller())

        # Setup Driven Joint
        bones = get_driven_joints(self, ueg_comp)
        ueg_comp.populate_bones(bones, bp_controller)

        # populate control positions
        ueg_comp.populate_control_transforms(bp_controller)

        ueg_comp.init_input_data(bp_controller)

    def group_components(self):
        """Loops over all components that have been created and generates a comment box and positions them in a
        more human readilbe layout.
        """

        controller = self.get_active_controller()

        for i, ue_comp in enumerate(self.uegear_components):

            pos = unreal.Vector2D(i * 512, 0)

            node_count = 0
            comment_size = 0

            for flow_name in ['construction_functions', 'forward_functions', 'backwards_functions']:
                nodes = ue_comp.nodes[flow_name]

                for n in nodes:
                    # Calculates the size of the node, via examination method
                    # todo: utilise calculation
                    (w, h) = calculate_node_size(n)
                    controller.set_node_position(n, pos + unreal.Vector2D(40, node_count * 300))
                    controller.set_node_position(ue_comp.comment_node, pos - unreal.Vector2D(5, 50))
                    node_count += 1

            comment_size = unreal.Vector2D(500, node_count * 300)
            # print(f"Comment Size {comment_size}")
            controller.set_node_size(ue_comp.comment_node, comment_size)

            # TODO: Rezise comment to encapsulate the entirety of control rig functions
            # TODO: Query the nodes pins and pin names to try and estimate the possible size of the node, then use that to drive the layout.

            # print("GROUP COMPONENTS")
            for node in ue_comp.get_misc_functions():
                (w, h) = calculate_node_size(node)
                # print(w, h)

                controller.set_node_position(node, pos + unreal.Vector2D(40, 450))

        # for i, ue_comp in enumerate(self.uegear_components):
        #     ue_comp.comment_node

    def build_components(self, manual_components: bool = False):
        """Builds all components
        """

        for comp in self.mg_rig.components.values():
            self.build_component(comp.fullname, manual_components)

    def populate_parents(self):
        """
        Assigns all the ueGear components parent child relationships.
        It does this by searching for the associated component by name.
        """
        print("---------------------------------")
        print(" Finding Parent Associations")
        print("---------------------------------")

        # Find the world component if it exists
        world_component = self.get_uegear_world_component()

        for comp in self.uegear_components:
            # Ignore world control
            if comp.metadata.comp_type == "world_ctl":
                continue
            # Ignore root component
            if world_component == comp:
                continue

            if comp.metadata.parent_fullname:
                parent_comp_name = comp.metadata.parent_fullname

                print(f" {comp.name} > Finding parent component: {parent_comp_name}")

                # parent_comp = self.mg_rig.components.get(parent_comp_name, None)
                parent_component = self.get_uegear_component(parent_comp_name)
                if parent_component is None:
                    print(f"    Could not find parent component > {parent_comp_name}")
                    continue

                print(f"      > Found parent component: {parent_comp_name}")
                comp.set_parent(parent_component)

            elif comp.metadata.parent_fullname is None and world_component:
                # Component has no parent specified, and a World Component exists
                # Set the World Component as the parent
                print(f" {comp.name} > Has no parent, World Component Exists")
                comp.set_parent(world_component)

        # initialises the manual parenting of python generated controls
        self.populate_manual_parents()

    def populate_manual_parents(self):
        # todo: once world control is generating a manual control then this can be updated to handle it. Currently cannot mix manual and procedural
        hrc_controller = self._active_blueprint.get_hierarchy_controller()

        for component in self.uegear_components:

            # skips any manual component building, if component is not manual.
            if not component.is_manual:
                continue

            # Skip world control if found, as world control does not parent to anything.
            if component.metadata.comp_type == "world_ctl":
                continue

            # If the component has no parent, then we assume it is needing the world control to be parented.
            if component.parent_node is None:
                continue

            # If the parent is the world control, then we force the parent_localname to be root
            if component.parent_node.name == "world_ctl":
                # Force the component that has no parent to be a child of the world_ctl
                component.metadata.parent_localname = "root"

            parent_control_relatives = component.parent_node.metadata.control_relatives
            if parent_control_relatives is None:
                continue

            # finds the parent name by looking up the parent_localname
            parent_control_name = parent_control_relatives[component.metadata.parent_localname]

            for child_ctrl_role in component.root_control_children:

                if child_ctrl_role not in component.control_by_role.keys():
                    print(f"Parenting Manual Component [{component.name.upper()}] - Skipping role {child_ctrl_role}")
                    continue

                # gets the control from the role name, using the lookup table
                child_ctrl = component.control_by_role[child_ctrl_role]

                hrc_controller.set_parent(
                    child_ctrl.rig_key,
                    unreal.RigElementKey(type=unreal.RigElementType.CONTROL, name=parent_control_name),
                    True)

        self.update_all_manual_control_transforms()

    # NOTE: This was removed as the order of applying transforms and there offsets was figured out and this post process
    # is no longer required
    def update_all_manual_control_transforms(self):
        """
        Manually generated controls rely on parent controls to exist to calculate the local offset.
        As the parent only exists after all the components have been generated and parented we run this .
        """
        hrc_controller = self._active_blueprint.get_hierarchy_controller()
        rig_hrc = hrc_controller.get_hierarchy()

        # Positions all controls in the correct World Position, and remove all the offset transform data
        for component in self.uegear_components:
            for role in component.control_by_role.keys():
                m_control = component.control_by_role[role]

                if (m_control.ctrl_type == unreal.RigElementType.NULL):
                    continue

                # Skip World Control as that is always at origin
                if m_control.name == "world_ctl":
                    continue

                manual_control_name = m_control.name
                control_transform_names = component.metadata.control_transforms.keys()

                transform = None

                for name in control_transform_names:
                    if name == manual_control_name:
                        transform = component.metadata.control_transforms[name]

                if transform is None:
                    continue

                # if m_control.name not in component.metadata.control_transforms.keys():
                #     unreal.log_error(f"Manual Control Position Update: Cannot find {m_control.name}")
                #     continue

                # transform = component.metadata.control_transforms[m_control.name]

                # Reset the offset values
                rig_hrc.set_control_offset_transform(
                    m_control.rig_key,
                    unreal.Transform(),
                    initial=True,
                    affect_children=False
                )

                rig_hrc.set_global_transform(
                    m_control.rig_key,
                    transform,
                    initial=True,
                    affect_children=False)

        # Reads the local position of the control and applies it as the offset then
        # removes the initial transform values.
        for component in self.uegear_components:
            for role in component.control_by_role.keys():
                m_control = component.control_by_role[role]

                if (m_control.ctrl_type == unreal.RigElementType.NULL):
                    continue

                initial_local_trans = rig_hrc.get_local_transform(
                    m_control.rig_key,
                    True)

                rig_hrc.set_control_offset_transform(
                    m_control.rig_key,
                    initial_local_trans,
                    initial=True,
                    affect_children=True
                )

                rig_hrc.set_local_transform(
                    m_control.rig_key,
                    unreal.Transform(),
                    initial=True,
                    affect_children=True)


    def connect_execution(self):
        """Connects the individual functions Execution port, in order of parent hierarchy"""

        keys = ['construction_functions',
                'forward_functions',
                'backwards_functions']

        bp_controller = self.get_active_controller()

        for func_key in keys:

            for comp in self.uegear_components:

                parent_nodes = self._find_parent_node_function(comp, func_key)
                comp_nodes = comp.nodes[func_key]

                if len(comp_nodes) == 0:
                    # The component contains no forward solve nodes ( in other words it doesn't drive a joint )
                    # No connection is required
                    continue

                # check parent node and comp node should always only be one node
                if len(comp_nodes) > 1:
                    unreal.log_error(f"There should not be more then one node per a function > {comp.name}")

                if parent_nodes is None:
                    unreal.log_error(f"No parent nodes found for {comp}")
                    continue

                p_func = parent_nodes.get_name()
                c_func = comp_nodes[0].get_name()

                # Check if parent node, has already been connected, else branch off

                execute_pin = parent_nodes.find_pin("ExecuteContext")
                target_pins = execute_pin.get_linked_target_pins()

                if len(target_pins) == 0:
                    # print("Pin not connected, setting up basic connection")
                    bp_controller.add_link(f'{p_func}.ExecuteContext',
                                           f'{c_func}.ExecuteContext')

                    print(f"CONNECTION: {p_func}.ExecuteContext > {c_func}.ExecuteContext")

                else:
                    # Checks if the pin belongs to a branch node, if not creates a branch node.

                    first_driven_node = target_pins[0].get_node()
                    is_sequence_node = str(first_driven_node.get_node_title()) == "Sequence"

                    if is_sequence_node:
                        # print("Sequence Node, insert new pin and connect")

                        source_node_name = p_func
                        new_connection_node_name = c_func
                        seq_node_name = f'{source_node_name}_RigVMFunction_Sequence'

                        # Generate next available plug on the Sequence Node
                        new_pin = bp_controller.add_aggregate_pin(seq_node_name, '', '')

                        try:
                            bp_controller.add_link(new_pin,
                                                   f'{new_connection_node_name}.ExecuteContext')
                            print(f"CONNECTION: {new_pin} > {new_connection_node_name}.ExecuteContext")
                        except:
                            print(f"FAILED: to connect {new_pin} > {new_connection_node_name}.ExecuteContext")


                    else:
                        # print("Creating Sequence Node for execution")

                        source_node_name = p_func
                        connected_node_name = first_driven_node.get_name()
                        new_connection_node_name = c_func
                        seq_node_name = f'{source_node_name}_RigVMFunction_Sequence'

                        # Create Sequence Node

                        bp_controller.add_unit_node_from_struct_path(
                            '/Script/RigVM.RigVMFunction_Sequence',
                            'Execute',
                            unreal.Vector2D(0.0, 1000.0),
                            seq_node_name)

                        # Connect Parent/Source node to the sequence node

                        bp_controller.add_link(f'{source_node_name}.ExecuteContext',
                                               f'{seq_node_name}.ExecuteContext')

                        # Connect Sequence node to the nodes that were connected to the Parent node, and the new
                        # node that will be connected.
                        bp_controller.add_link(f'{seq_node_name}.A',
                                               f'{connected_node_name}.ExecuteContext')
                        bp_controller.add_link(f'{seq_node_name}.B',
                                               f'{new_connection_node_name}.ExecuteContext')

    def _find_parent_node_function(self, component, function_name: str):
        """Recursively looks at the function, then if one does not exist looks for
        the next one in the parent/child hierarchy

        function_name : is the name of the evaluation function, forward, backwards, construction.
        """

        solve = {'construction_functions': self.get_construction_node(),
                 'forward_functions': self.get_forward_node(),
                 'backwards_functions': self.get_backwards_node()
                 }

        parent_comp = component.parent_node

        if parent_comp is None:
            return solve[function_name]

        comp_nodes = parent_comp.nodes[function_name]

        if len(comp_nodes) > 1:
            unreal.log_error(f"There should not be more then one node per a function > {parent_comp.name}")

        if len(comp_nodes) == 0:
            return self._find_parent_node_function(parent_comp, function_name)

        return comp_nodes[0]

    def pin_exists(self, function: unreal.RigVMNode, pin_name: str, input_pin: bool = True) -> bool:
        """Checks if a pin exists as in input our output
        function
        """
        for pin in function.get_pins():
            name = pin.get_display_name()

            if name != pin_name:
                continue

            pin_direction = pin.get_direction()
            if pin_direction == unreal.RigVMPinDirection.INPUT and input_pin:
                return True
            elif pin_direction == unreal.RigVMPinDirection.OUTPUT and not input_pin:
                return True
        return False

    def connect_construction_functions(self):
        """Connects all the construction functions in control rig"""
        construction_key = 'construction_functions'

        bp_controller = self.get_active_controller()

        # Find the world component if it exists
        root_comp = self.get_uegear_world_component()

        for comp in self.uegear_components:

            # Ignore world control
            if comp.metadata.comp_type == "world_ctl":
                continue
            # Ignore root component
            if root_comp == comp:
                continue

            parent_comp_name = comp.metadata.parent_fullname
            parent_pin_name = comp.metadata.parent_localname

            print(f" -- {comp.name} --")

            if comp.parent_node is None:
                print(f"  Parent Node does not exist in graph: {parent_comp_name}")
                continue

            print(f"  parent: {parent_comp_name}")
            print(f"  parent port: {parent_pin_name}")
            print(f"  Relationship Parent: {comp.parent_node.name}")

            # component is an 'locator' port, which is made up of an array.
            # This plug needs to get converted from an array out plug to the correct plug index
            if parent_pin_name is not None:
                if parent_pin_name.endswith('_loc'):
                    print(f"_loc found in {parent_pin_name}")
                    loc_index = str(int(parent_pin_name.split("_")[0]))
                    parent_node_name = comp.parent_node.nodes[construction_key][0].get_name()

                    # Creates an At Node, Sets its Index and connects it to the output locator

                    at_node_name = parent_node_name + "_output_loc_" + str(loc_index)
                    at_node = bp_controller.add_template_node(
                        'DISPATCH_RigVMDispatch_ArrayGetAtIndex(in Array,in Index,out Element)',
                        unreal.Vector2D(3500, 800),
                        at_node_name
                    )

                    comp.parent_node.add_misc_function(at_node)

                    bp_controller.set_pin_default_value(
                        f'{at_node_name}.Index',
                        loc_index,
                        False)

                    bp_controller.add_link(
                        f'{parent_node_name}.loc',
                        f'{at_node_name}.Array'
                    )

                    c_func_name = comp.nodes[construction_key][0].get_name()
                    bp_controller.add_link(f"{at_node_name}.Element",
                                           f"{c_func_name}.parent")
                    continue

            if parent_comp_name is None and comp.parent_node.name == "world_ctl":
                # Defaulting to the world control, the output pin is "root"
                parent_pin_name = "root"

                print("    Connect to World Control")
                print(f"      Parent Pin: {parent_pin_name}")

                parent_comp = comp.parent_node

                comp_functions = comp.nodes[construction_key]
                parent_functions = parent_comp.nodes[construction_key]

                # If the component or parent has no functions then skip the function
                # TODO: This should walk up the ueGear node parent relationship to see what is available to connect to
                if len(comp_functions) == 0 or len(parent_functions) == 0:
                    continue

                comp_function = comp_functions[0]
                parent_function = parent_functions[0]

                # Connects the parent function node to the chile function node..
                p_func_name = parent_function.get_name()
                c_func_name = comp_function.get_name()

                bp_controller.add_link(f"{p_func_name}.{parent_pin_name}",
                                       f"{c_func_name}.parent")

            elif parent_comp_name == comp.parent_node.name:
                print("  Connect via relationships/Association")
                print(f"      Parent Pin: {parent_pin_name}")

                parent_comp = comp.parent_node

                comp_functions = comp.nodes[construction_key]
                parent_functions = parent_comp.nodes[construction_key]

                # If the component or parent has no functions then skip the function
                # TODO: This should walk up the ueGear node parent relationship to see what is available to connect to
                if len(comp_functions) == 0 or len(parent_functions) == 0:
                    continue

                comp_function = comp_functions[0]
                parent_function = parent_functions[0]

                # Connects the parent function node to the chile function node..
                p_func_name = parent_function.get_name()
                c_func_name = comp_function.get_name()

                # Checks parent node has output pin with the specified name
                found_pin = parent_function.find_pin(parent_pin_name)
                if found_pin:
                    if found_pin.get_direction() == unreal.RigVMPinDirection.OUTPUT:
                        bp_controller.add_link(f"{p_func_name}.{parent_pin_name}",
                                               f"{c_func_name}.parent")
                        continue

                # Function that returns the correct pin from the name of the parent_pin_name
                # If no pin is found then we fall back to specified parent mGear name.
                pin = parent_comp.get_associated_parent_output(parent_pin_name, bp_controller)

                if pin:
                    print(f"Associated Parent Pin : {pin}")
                    print(f"{pin} > {c_func_name}.parent ")

                    bp_controller.add_link(pin,
                                           f"{c_func_name}.parent")
                else:
                    print(f"{p_func_name}.{parent_pin_name} > {c_func_name}.parent ")

                    bp_controller.add_link(f"{p_func_name}.{parent_pin_name}",
                                           f"{c_func_name}.parent")

            else:
                unreal.log_error(f"Invalid relationship data found: {comp.name}")

    def connect_forward_functions(self):
        """Triggers the forward function connections if the component
        contains the specific method."""

        for comp in self.uegear_components:
            comp.forward_solve_connect(self.get_active_controller())

    def connect_components(self):
        """Connects all the built components"""

        self.connect_execution()

        print("---------------------------------")
        print("     Connecting Components       ")
        print("---------------------------------")

        self.connect_construction_functions()
        self.connect_forward_functions()

        return

        bp_controller = self.get_active_controller()

        # Find the world component if it exists
        root_comp = self.get_uegear_world_component()

        for comp in self.uegear_components:

            # Ignore world control
            if comp.metadata.comp_type == "world_ctl":
                continue
            # Ignore root component
            if root_comp == comp:
                continue

            print(f" -- {comp.name} --")

            print(f"  parent: {comp.metadata.parent_fullname}")
            print(f"  parent port: {comp.metadata.parent_localname}")
            print(f"  Relationship Parent: {comp.parent_node.name}")

            if comp.metadata.parent_fullname is None and comp.parent_node.name == "world_ctl":
                print("   Connect to World Control")

                keys = ['construction_functions',
                        'forward_functions',
                        'backwards_functions']

                parent_comp = comp.parent_node

                for evaluation_key in keys:
                    comp_functions = comp.nodes[evaluation_key]
                    parent_functions = parent_comp.nodes[evaluation_key]

                    # If the component or parent has no functions then skip the function
                    # TODO: This should walk up the ueGear node parent relationship to see what is available to connect to
                    if len(comp_functions) == 0 or len(parent_functions) == 0:
                        continue

                    comp_function = comp_functions[0]
                    parent_function = parent_functions[0]

                    print(f"   Function Name: {comp_function}")
                    # print(comp_function.get_pins())  # Gets all the pins that are available on the function
                    for pin in comp_function.get_pins():
                        pin_name = pin.get_display_name()
                        pin_direction = pin.get_direction()
                        print(f"      {pin_name} : {pin_direction}")

                    print(parent_function)

                    # Connects the parent function node to the chile function node..

                    # This implementation is assumin to much, needs to be more generic
                    p_func_name = parent_function.get_name()
                    c_func_name = comp_function.get_name()

                    bp_controller.add_link(f"{p_func_name}.root",
                                           f"{c_func_name}.parent")


            elif comp.metadata.parent_fullname == comp.parent_node.name:
                print("  Connect via relationships/Association")
            else:
                unreal.log_error(f"Invalid relationship data found: {comp.name}")

        # loop over components
        # if world exists then it is the master root
        # if no world exists then we might have to seach for parents and see what is available

    def get_uegear_world_component(self) -> components.base_component.UEComponent:
        for comp in self.uegear_components:
            if comp.metadata.comp_type == "world_ctl":
                return comp

    def get_uegear_component(self, name) -> components.base_component.UEComponent:
        """Find the ueGear component that has been created.
        If the component cannot be found it means that it has not been generated yet.

        :param str name: The name of the ueGear component you wish to find.
        :return: The UEComponent that exists with the matching name.
        :rtype: components.base_component.UEComponent or None
        """
        for ue_component in self.uegear_components:
            if ue_component.name == name:
                return ue_component
        return None

    # SUB MODULE - Control Rig Interface. -------------
    #   This may be abstracting away to much

    def get_node(self, node_name: str,
                 create_if_missing: bool = False, function_path: str = None,
                 function_name: str = None) -> Optional[unreal.RigVMNode]:
        """
        Gets a node by name in the current graph that is active in the Manager.

        :param str node_name: Name of the node that is to be retrieved.
        :param bool create_if_missing: If the node does not exist then create it
        :param str function_path: Path to the function library that contains the function to be created.
        :param str function_name: Name of the function node that will be created.
        :return: Node that is found or created, else None.
        :rtype: unreal.RigVMNode or None
        """
        graph = self.get_graph()

        if graph is None:
            unreal.log_error("No graph object found in manager, please make sure an active blueprint is set.")
            return None

        node = graph.find_node_by_name(node_name)

        if node is None and create_if_missing and function_path and function_name:
            node = self.create_node()

        return node

    def create_node(self):
        raise NotImplementedError

    def select_nodes(self):
        raise NotImplementedError

    # ---------------------------------------

    def create_control_rig(self, cr_path: str, cr_name: str, skm_package_path: str, set_default=True, constructionControls=False):
        """Generates a new Control Rig Blueprint

        NOTE: This method requires a Skeleton Mesh to generate the Control Rig.

        By default, this will fail if a control rig already exists at the location.
        The newly created control rig will be set to the "Active Control Rig"

        cr_name:str = Name of the control rig file
        cr_path:str = Package Path to the location where the new cr will be generated.
        skeleton_path = Path to the Skeleton Mesh object that will be used to generate the control rig
        """

        self.buildConstructionControlFunctions = constructionControls

        package_path = unreal.Paths.combine([cr_path, cr_name])
        if unreal.Paths.file_exists(package_path):
            unreal.log_error("Control Rig File already exists")
            return None

        if not ue_assets.asset_exists(skm_package_path):
            unreal.log_error(f"Skeleton Mesh not found - {skm_package_path}")
            return None

        # Generates Control Rig Blueprint in place
        skm_obj = ue_assets.get_asset_object(skm_package_path)
        blueprint = self._factory.create_control_rig_from_skeletal_mesh_or_skeleton(skm_obj)

        if blueprint is None:
            unreal.log_error(f"Failed to create Control Rig BP - {package_path}")
            return None

        # Move blueprint to correct location
        moved_success = unreal.EditorAssetLibrary.rename_asset(blueprint.get_path_name(), package_path)
        if not moved_success:
            unreal.log_error(f"Failed to rename Control Rig BP - {blueprint.get_path_name()}")
            # Deletes invalid CRBP which is now stale, and should not exist in this location.
            unreal.EditorAssetLibrary.delete_asset(blueprint.get_path_name())
            return None

        if set_default:
            self.set_active_blueprint(blueprint)

        # Create Forwards, Backwards and Construction Solve Node
        self.create_solves()

        return blueprint

    def create_controlrig_by_location(self, package_path, set_default=True):
        """
        Creates the control rig at the specific location, and set the manager to use the newly created control rig.

        package_path: path to the newly created control rig blue print.
        set_default: If disabled, the manager will not automatically set the active CR BP to the newly created CR BP.
        """
        factory = unreal.ControlRigBlueprintFactory()
        rig = factory.create_new_control_rig_asset(desired_package_path=package_path)

        if set_default:
            self._active_blueprint = rig

        return rig

    def create_controlrig_by_mesh(self, mesh_package_path):
        """Generates the control rig using the mesh package path"""
        # load a skeletal mesh
        mesh = unreal.load_object(name=mesh_package_path, outer=None)
        # create a control rig for the mesh
        factory = unreal.ControlRigBlueprintFactory
        rig = factory.create_control_rig_from_skeletal_mesh_or_skeleton(selected_object=mesh)
        return rig

    def set_active_control_rig(self, path=None):
        """
        Sets the active control rig to be the selected control rig blue print in the Content Browser.
        """

        if path:
            loaded_control_rig = unreal.load_object(name=path, outer=None)
            self.set_active_blueprint(loaded_control_rig)

            if loaded_control_rig == None:
                print(f"Warning: No Control Rig Blue Print found at {path}")
                return None

            return loaded_control_rig

        selected_blueprints = ue_assets.selected_assets(unreal.ControlRigBlueprint)

        self._set_control_blueprint(selected_blueprints)

        return self._active_blueprint

    def load_rig(self, mgear_rig: mgear.mgRig):
        """
        Loads the mgear rig object into the manager, so the manager can generate the control rig and its components.
        """
        self.mg_rig = mgear_rig

    def get_graph(self) -> unreal.RigVMGraph:
        """
        Gets the graph of the current loaded control rig

        https://docs.unrealengine.com/5.3/en-US/PythonAPI/class/RigVMGraph.html#unreal.RigVMGraph

        """
        rig_vm_controller = self._active_blueprint.get_controller_by_name('RigVMModel')

        if rig_vm_controller is None:
            # If Controller cannot be found, create a new controller
            rig_vm_controller = self._active_blueprint.get_or_create_controller()

        active_cr_graph = rig_vm_controller.get_graph()
        return active_cr_graph

    def get_active_controller(self, name: str = "RigVMModel") -> unreal.RigVMController:
        """
        Returns the active control rig blue print controller.

        name:str = The name of the blueprint controller.
        """
        rig_vm_controller = self._active_blueprint.get_controller_by_name(name)

        # If Controller cannot be found, create a new controller
        if rig_vm_controller is None:
            rig_vm_controller = self._active_blueprint.get_or_create_controller()

        return rig_vm_controller

    def get_selected_nodes(self) -> list[str]:
        if self._active_blueprint is None:
            print("Error, please set the sctive Control Rig blueprint.")
        graph = self.get_graph()
        return graph.get_select_nodes()

    def create_solves(self):
        """
        Creates the Execution Nodes, for the following paths, as they are not created by default.
        - Forward
        - Backwards (Inverse)
        - Construction
        """

        rig_vm_controller = self.get_active_controller()

        if rig_vm_controller is None:
            unreal.log_error("No Control Rig Controller found, please open up a control Rig UI and try again")
            return

        position_offset = unreal.Vector2D(-300, 0)

        # Forward
        if not self.get_node("BeginExecution") and not self.get_node("RigUnit_BeginExecution"):
            rig_vm_controller.add_unit_node_from_struct_path(
                '/Script/ControlRig.RigUnit_BeginExecution',
                'Execute',
                position_offset + unreal.Vector2D(0, 512),
                'BeginExecution')

        # Backward
        if not self.get_node("InverseExecution"):
            rig_vm_controller.add_unit_node_from_struct_path(
                '/Script/ControlRig.RigUnit_InverseExecution',
                'Execute',
                position_offset + unreal.Vector2D(0, 1024),
                'InverseExecution')

        # Construction
        if not self.get_node("PrepareForExecution"):
            rig_vm_controller.add_unit_node_from_struct_path(
                '/Script/ControlRig.RigUnit_PrepareForExecution',
                'Execute',
                position_offset,
                'PrepareForExecution')

    def get_forward_node(self) -> unreal.RigVMNode:
        """Gets the Forward Execution Node"""
        return self.get_node('BeginExecution')

    def get_backwards_node(self) -> unreal.RigVMNode:
        """Gets the Backwards Execution Node"""
        return self.get_node('InverseExecution')

    def get_construction_node(self) -> unreal.RigVMNode:
        """Gets the Construction Execution Node"""
        return self.get_node('PrepareForExecution')


def get_forward_solve(manager: UEGearManager):
    controller = manager.get_active_controller()
    controller.set_node_selection(['RigUnit_BeginExecution'])
    # manager.active_control_rig.get_controller_by_name('RigVMModel').get
    raise NotImplementedError


def get_driven_joints(manager: UEGearManager, ueg_component: components.base_component.UEComponent):
    """
    Finds all the bones is they exist that populate the ueGear metadata joint property.
    """
    joint_names = ueg_component.metadata.joints

    if joint_names is None:
        return

    rig_hierarchy = manager.active_control_rig.hierarchy

    found_bones = []

    for name in joint_names:
        rek = unreal.RigElementKey()
        rek.name = name
        rek.type = unreal.RigElementType.BONE
        bone = rig_hierarchy.find_bone(rek)

        if bone.index == -1:
            unreal.log_error(f"[get_driven_joints] Bone '{name}' could not be found using the following key {rek}")

# ======================== PATCH ====================================
#        Solution in unreal 5.4, 5.5. Not required in 5.3
        engine_version = unreal.SystemLibrary.get_engine_version()
        if int(engine_version.split(".")[1]) > 3:
            bone = unreal.RigBoneElement(rek)
# ======================== END PATCH ================================

        if bone:
            found_bones.append(bone)

    ueg_component.bones = found_bones

    return found_bones


def create_array_node(node_name: str,
                      controller: unreal.RigVMController,
                      pos_x: float = 700,
                      pos_y: float = 700) -> str:
    """Generates a make array node"""

    array_node_name = f"{node_name}_arrayNode"

    found_node = controller.get_graph().find_node_by_name(array_node_name)

    if not found_node:
        controller.add_template_node(
            'DISPATCH_RigVMDispatch_ArrayMake(in Values,out Array)', unreal.Vector2D(pos_x, pos_y),
            array_node_name)

    return array_node_name


def array_node_has_pins(node_name: str,
                        controller: unreal.RigVMController,
                        minimum_pins: int = 1):
    """
    Checks if the array node contains any pins.

    As different nodes get generated with different default pin values, we have a minimum cound to query against.
    """
    # Checks if node exists, else creates node
    found_node = controller.get_graph().find_node_by_name(node_name)

    # Do pins already exist on the node, if not then we will have to create them. Else we dont
    existing_pins = found_node.get_pins()[0].get_sub_pins()

    if len(existing_pins) > minimum_pins:
        return True

    return False


def calculate_node_size(node: unreal.RigVMUnitNode):
    """
    Calculates the node size by checking the amount of input and output pins,
    as well as the names of the pins.
    """
    # todo: calculate the size of  node by the amount of pins and size of the name
    input_pins = []
    outpu_pins = []
    longest_input_name = ""
    longest_output_name = ""
    node_name = node.get_name()

    for pin in node.get_pins():

        pin_name = str(pin.get_display_name())

        if pin.get_direction() == unreal.RigVMPinDirection.INPUT:
            input_pins.append(pin)
            if len(pin_name) > len(longest_input_name):
                longest_input_name = pin_name

        if pin.get_direction() == unreal.RigVMPinDirection.OUTPUT:
            outpu_pins.append(pin)
            if len(pin_name) > len(longest_output_name):
                longest_output_name = pin_name

    # print(f"{len(input_pins)} > {node_name} > {len(outpu_pins)}")
    # print(f"{len(longest_input_name)} > {node_name} > {len(longest_output_name)}")

    offset = 11
    char_width = 3
    char_height = 8

    width = len(longest_input_name) * char_width + offset + \
            len(node_name) * char_width + offset + \
            len(longest_output_name) * char_width

    height = (len(input_pins) + 1) * char_height + \
             1 * char_height + \
             (len(outpu_pins) + 1) * char_height

    return (width, height)


def create_control_rig(rig_name: str, skeleton_package: str, output_path: str, gnx_path: str, constructionControls: bool):
    """
    Generates the control rig from the available components

    constructionControls: bool
        Generate all Control Rig controls using the Construction Node, this allows the rig to automatically be build
        every compile, but doesn't allow for post build customisation.
    """
    TEST_BUILD_JSON = gnx_path
    TEST_CONTROLRIG_PATH = output_path
    TEST_CONTROLRIG_NAME = rig_name
    TEST_CONTROLRIG_SKM = skeleton_package

    print("-------------------------------------------")
    print(" Creating Control Rig from mGear .gnx file")
    print(f"   {rig_name}")
    print(f"   {skeleton_package}")
    print(f"   {output_path}")
    print(f"   {gnx_path}")
    print("-------------------------------------------")

    # Converts teh json data into a class based structure, filters out non-required metadata.
    mgear_rig = mgear.convert_json_to_mg_rig(TEST_BUILD_JSON)

    gear_manager = UEGearManager()
    gear_manager.load_rig(mgear_rig)
    gear_manager._buildConstructionControlFunctions = constructionControls

    # Creates an asset path
    cr_path = TEST_CONTROLRIG_PATH + "/" + TEST_CONTROLRIG_NAME
    # Control Rig Blueprint
    cr_bp = ue_assets.get_asset_object(cr_path)

    print(f" --  Could not find Control Rig Blueprint > {cr_bp}")

    if cr_bp is None:
        print(f" --  Creating Control Rig Blueprint > {cr_path}")
        cr_bp = gear_manager.create_control_rig(TEST_CONTROLRIG_PATH, TEST_CONTROLRIG_NAME, TEST_CONTROLRIG_SKM)
        if cr_bp is None:
            unreal.log_error("No Control Rig Graph found..")
            return

    # ------ Causes Unreal to Crash -------
    # aes = unreal.AssetEditorSubsystem()
    # aes.open_editor_for_assets([cr_bp])
    # -------------------------------------

    gear_manager.set_active_blueprint(cr_bp)

    # Deactivate Autocompile, to speed up builds
    compile_status = gear_manager.get_compile_mode()
    # gear_manager.set_compile_mode(False)

    # todo: commented out as the folder should only be deleted if it is empty.
    # if cr_bp is None:
    #     unreal.log_error("Test: test_create_fk_control - Failed : Could not create control rig blue print")
    #     unreal.EditorAssetLibrary.delete_directory("/Game/TEST/")
    #     return None

    # - At this point we now have The Manager, with an empty Control Rig BP
    # Builds the world control if it has been enabled in the Main Settings
    gear_manager.build_world_control()
    gear_manager.build_components(manual_components=not constructionControls)

    # - At this point there are many components created, but not connected to one another
    gear_manager.populate_parents()
    gear_manager.connect_components()
    gear_manager.group_components()

    # Sets the auto-compiler back to how it was before building
    # gear_manager.set_compile_mode(compile_status)
